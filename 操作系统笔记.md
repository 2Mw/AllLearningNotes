# 操作系统

[TOC]

## 操作系统概述

### 概念:

1. 控制和管理软件和硬件资源，是系统资源的管理者
2. 给用户和其他软件方便的接口和环境，给上次提供方便易用的服务
3. 是计算机系统的最基本软件

<img src="https://i.loli.net/2021/08/03/Q67UXOiSbdDNLvk.png" alt="image-20200502095850287" style="zoom: 50%;" />

### 操作系统的功能

举个例子：用QQ和朋友视频聊天的过程

step1：在文件夹中找到QQ的位置			-> 文件管理

step2：打开QQ										 -> 存储器管理

step3：QQ正常运行								  -> 处理机(CPU)管理

step4：和朋友视频聊天							 -> 设备管理

 

**操作系统提供的服务：**

对上层：GUI  命令接口（联机|脱机命令接口）  程序接口

对下层：对硬件的拓展，将硬件合理的组织在一起

### 操作系统的四个特征

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200502102924913.png" alt="image-20200502102924913" style="zoom: 33%;" />

注意 :exclamation: ：

单核CPU同一时刻只能运行一个程序，各个程序只能**并发**执行

多核CPU同一时刻可以运行多个程序，各个程序可以**并行**执行

**并发性**：宏观上是“同时运行”，微观上是交替运行。

**共享性**：互斥共享和同时共享。互斥共享：在一个时间段只允许一个程序访问资源。同时共享：在一个时间段内某资源可以由多个进程“同时”对他们访问。例如，摄像头的互斥性，不同进程发送文件的共享性

并发性和共享性互为存在条件：如果不能并发，共享将没有意义，反之相同。

**虚拟性**：虚拟存储器和虚拟处理器的技术，空分/时分复用技术。

**异步性**：在多道程序处理环境下，由于资源有限，程序不可能一贯到底，而是走走停停，以不可预知的情况下进行

只有系统有并发性才能有异步性。

### 操作系统的发展和分类

<img src="https://i.loli.net/2021/08/03/B9noAUMFTZY2Oy1.png" alt="image-20200502104958543" style="zoom: 50%;" />



**手工操作系统**：人机速度矛盾，资源利用率极低

**批处理阶段**：单道批处理和多道批处理。引入了脱机输入和输出系统，由监督程序控制作业的输入输出。但是没有人机交互，用户提交作业之后只能等待计算机完成，中间不能控制自己的作业（无法调试程序）。

**分时操作系统**：以时间片为单位轮流为用户/程序服务。解决的人机交互问题，多个用户可以同时使用一台计算机，操作之间相互独立，感受不到别人的存在。

**实时操作系统**：分为软实时系统和硬实时系统。能够优先响应一些紧急任务。要在严格的时间内完成事件。主要特点就是“及时性”和“可靠性”。

### 操作系统的运行机制

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200502110432030.png" alt="image-20200502110432030" style="zoom:50%;" />

指令：分为特权指令和非特权指令。CPU根据自己当前的状态来决定是否执行特权指令。CPU中有一个**程序状态字寄存器**PSW寄存器，其中的一个二进制位1表示内核态，0表示用户态。（又分别称为管态和目态）

两个运行状态的转换：

内核态 -> 用户态：一条修改PSW的特权指令

用户态 -> 内核态： 由中断引起，硬件自动完成

### 中断和异常

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200504135848371.png" alt="image-20200504135848371" style="zoom:67%;" />

> 中断是操作系统内核重新夺回CPU使用权的唯一途径

如果没有中断机制，一旦应用程序在CPU上运行，CPU就会一直运行下去。那不会有"并行"的概念

类型：内中断和外中断

内中断：来源于CPU内部，与当前指令有关。例如特权指令或者除0操作，或者是“陷入指令”

外中断：来源于CPU外部，与当前指令无关。例如时钟中断为程序并行，当一个程序执行满一段时间后，切换为另一个程序；还有输入输出设备

中断的处理：不同的中断信号，需要不同的中断处理程序来处理。当CPU检测到中断信号的时候，会根据中断的类型去查询“中断向量表”，来找到对应的中断程序。因此中断程序也是内核程序。

### 系统调用

概念：操作系统提供给应用程序使用的接口，应用程序通过系统提供的接口请求相关的操作系统服务。

为什么系统调用：比如应用程序对共享资源的管理，不同应用程序对打印机的使用，如果不进行同统一管理会造成打印结果混乱。凡是对共享资源相关的操作，都会通过操作系统来处理。

分类：

```
设备管理
文件管理
进程控制
进程通信
内存管理
```

调用的过程：首先需要传递参数，然后执行陷入指令，触发内中断，执行相关内核函数，执行完成后，再转回用户态

注意 :exclamation: ：

1. 陷入指令=trap指令=访管指令
2. 陷入指令是执行再用户态

### 操作系统的体系结构

内核：大内核和微内核

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200504142629306.png" alt="image-20200504142629306" style="zoom: 67%;" />

CPU状态转换的过程是要消耗不少时间，频繁的转换会降低系统性能。

大内核：Linux，高性能，但内容庞杂   微内核：windows，结构清晰但方便维护

## 进程管理

### 基本概念

> 进程是操作系统资源分配和调度的独立单位

进程与程序：进程是动态的，程序是静态的。相同程序可以有不同的进程。

进程的组成：PCB是进程存在的唯一标志，存放比如PID，UID，资源分配情况，处理机相关信息。一个进程实体由PCB，程序端，数据段组成。

### 进程的特征

> 最基本特征：动态性

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200504151523644.png" alt="image-20200504151523644" style="zoom:67%;" />

### 进程的状态与转换

状态：

创建态：进程正被创建时，分配资源，创建PCB

就绪态：已经具备运行的条件，由于没有空闲的CPU，所以不能运行

运行态：正在运行的程序

阻塞态：请求资源但是资源不足，进程无法继续运行。直到有资源时候进入就绪态。

终止态：exit之后，系统会回收对应的进程资源

“丁字裤”模型：

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200504153158169.png" alt="image-20200504153158169" style="zoom:67%;" />

### 进程的链接方式

> 有链表方式和索引方式

1. 执行指针
2. 就绪队列指针：一般优先级高的放在队头
3. 阻塞队列指针：一般根据请求的资源分成不同的阻塞队列

### 进程控制

> 对操作系统中的所有进程进行有效的管理。即实现进程状态的转换，需要使用“原语”来实现。

“原语”的执行是具有原子性的，不可被中断。否则会导致系统出错。

可以使用“开中断”和“关中断”指令实现原子性。

进程控制相关的原语：

```
创建原语
终止原语
阻塞原语：保护运行现场，将PCB插入阻塞队列
唤醒原语：找到PCB，设置为就绪态
切换原语：当一个程序的时间片到时候转为就绪态，选取一个PCB转为运行态并且还原运行状态。
```

### 进程通信

> 进程之间的信息交换，一个进程不能直接访问另一个进程的内存地址

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200507075405200.png" alt="image-20200507075405200" style="zoom:67%;" />

1. 共享存储：对共享空间的访问必须是**互斥**的。基于数据结构的存储：只能存放一个长度为10的数组。这种共享方式速度慢，限制多。属于低级通信。基于存储区的共享：在内存中画出一块共享存储区，数据的形式、存放位置都有**进程**来控制。属于高级通信。

2. 管道通信：”管道“即链接读写进程的共享文件，就是内存中开辟的固定大小的缓冲区。只能采用**半双工**通信。访问管道也是**互斥**进行的。如果实现双向同时通信，需要两个管道。数据以字符流形式进入管道，当管道只有被写满时写进程会被阻塞，等待管道将对应数据全部取走的时候才可以进行写入文件，读进程进入阻塞。

   如果没有写满就不允许读，没有读空就不允许写。

   缺点：数据一旦被读出就从管道中被抛弃，就意味着读进程只能有一个，否则会出现读错数据的情况

3. 消息传递：进程间的数据交换以格式化的消息为单位。操作系统通过”发送消息/接受消息两个原语进行数据交换“。

   消息结构分为：消息头和消息体。消息头包括：发送进程ID、接受进程ID，消息类型等信息。

   消息分类为：直接通信方式（直接把消息挂到接收进程的消息缓冲队列上）和间接通信方式（拥有中间实体的**信箱通信方式**）。

### 线程

> 进程需要执行很多事情，因此引入了”线程“。可理解为”轻量级“进程

线程时基本的CPU执行单元，也是程序执行流的最小单位。进程只作为除CPU之外资源分配的基本单位，线程时调度的基本单位。

引用线程后，由于不需要切换运行环境，操作系统并发开销减小。

**属性：**

```
线程是处理机调度的基本单位。
各个线程可占用不同的CPU
每个线程都有线程ID，线程控制块
线程也有阻塞，就绪，运行三个基本状态。
线程几乎不拥有系统资源，同一进程不同线程拥有共享进程的资源，因此线程通信无需操作系统干预。
同一进程不同线程的切换不引起进程切换。不同的会引起。
切换同进程的线程系统开销很少，否则很大。
```

### 线程的实现方式

用户级线程：由程序员的线程库实现的。线程的管理由进程进行，不需要CPU变换状态，操作系统意识不到线程的存在。不需要切换核心态，开销小，效率高。缺点是一个”线程“阻塞，其他线程也会被阻塞，并发度不高，不能在多核机上运行。

内核级线程：由操作系统管理，需要CPU转换为核心态。并发能力强，可在多核CPU上并行进行。但一个进程可能占用多个内核线程，开销大。

**多线程模型**：

一对一模型：同内核级线程

多对一模型：相当于纯粹的”用户级线程“。<font color="red">操作系统只"看得见"内核级线程，因此内核级线程才是处理机分配的基本单位。</font>

多对多模型：n个用户级线程对应m个内核级线程(n>m)，克服了多对一并发度不高的特点，也解决的一对一开销大的缺点

用户级线程相当于是”代码逻辑“的载体。

内核级线程相当于是”运行机会“的载体。

### 处理机调度

调度：运用某周规则来决定任务的顺序。

**高级调度**：按照一定原则从外存作业的后备队列中挑选一个作业调入内存，并创建进程。每个作业只调入一次，调出一次。作业调入时候会创建PCB，调出时会撤销PCB。

**低级调度（进程调度/处理机调度）：**是最基本的调度，在一般操作系统中都必须配置进程调度。频率很高，一般几十毫秒一次。

**中极调度（内存调度）：**内存不够时，将某些进程数据调出设置为挂起状态，组织成挂起队列。中级调度比高级调度频率更高。

挂起又分为就绪挂起和阻塞挂起状态。

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200507085545366.png" alt="image-20200507085545366" style="zoom:67%;" />

### 三种调度方式的联系和区别

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200507085645096.png" alt="image-20200507085645096" style="zoom:67%;" />

### 切换和进程调度方式

主动放弃：1. 进程正常终止 2. 运行过程出现异常而终止  3. 进程主动请求阻塞（I/O请求）

被动放弃：1. 分给进程的时间片用完  2. 有更紧急的事需要处理（I/O中断） 3. 有更高优先级进程进入就绪队列

**不能切换进程**的情况：

1. 中断过程复杂，与硬件密切相关，很难做到中断处理过程中进行进程切换。  

2. 进程在操作系统内核程序临界区中。  

   解释：

   ​	临界资源：一个时间段内只允许一个程序使用的资源。各个进程需要互斥的访问资源。

   ​	临界区：访问临界资源的那段代码

   ​	内核程序的临界区：用于访问内核数据结构，比如进程的就绪队列。

   ​	普通的临界区：不会直接影响操作系统内核的管理。因此可以进行调度和切换。

   ```
   例题：
   	进程在操作系统内核程序临界区不能进行调度和切换。		√
   	进程处于临界区不能进行处理机调度。				 	 ×
   ```

   <img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200507091411424.png" alt="image-20200507091411424" style="zoom:67%;" />

3. 在原子操作中（原语）。

**进程调度的方式**：

非剥夺调度方式：又称为非抢占式。只允许进程主动放弃处理机。简单开销小但无法处理紧急任务。

剥夺调度方式：又称为抢占式。可以使进程按时间片的方式轮流执行功能，适合分时操作系统、实时操作系统。如果有紧急任务，暂停当前执行的任务，允许紧急程序。

广义的进程调度：包含选择一个进程和进程切换两个步骤。

**进程切换**过程：1. 进行数据保存 2. 对新的进程各种数据的恢复。

如果进程切换的频率过于频繁，会降低并发度。

### 调度算法的评价指标

1. CPU利用率：= 忙碌的时间 / 总时间

2. 系统吞吐量：单位时间内完成作业的数量。 多少道作业 /  花费时间

3. 周转时间：从提交作业系统开始直到作业完成的这段时间间隔。= 作业完成时间 - 作业提交时间。它包括四个部分:作业在外存后备队列上等待作业调度( 高级调度)的时间、进程在就绪队列上等待进程调度(低级调度)的时间、进程在CPU.上执行的时间、进程等待I/O操作完成的时间。后三项在一个作业的整个处理过程中，可能发生多次。

4. 平均周转时间： 各作业周转时间之和 / 作业数

   带权周转时间：= 作业周转时间 / 作业实际运行时间  ≥1

   平均带权周转时间： =  各作业带权周转时间之和 / 作业数

5. 等待时间：对于进程来说指进程建立后等待被服务的时间之和；其中等待I/O完成不能算是等待时间。对于作业来说，不仅要考虑建立进程后的等待时间，还要考虑作业在外存后备队列的等待时间。

   平均等待时间： 各作业等待时间之和 / 作业数

6. 响应时间

### ※调度算法——1※

> 注意点:1.算法思想 2.算法规则 3. 是作业调度还是进程调度 4.抢占式和非抢占式 5.优缺点 6是否导致饥饿（作业长期得不到服务）

<font color="red">这几种多用于早期批处理程序，与用户交互性差</font>

FCFS：谁先来谁先服务

SJF：选择当前时间已经到达的最短服务

SRTN：选择当前到达处理机运行最少剩余时间的进程，抢占式

HRNN：选择响应比【=(等待时间+要求服务时间)/要求服务时间】最高的作业/进程来为其服务

|               | 先来先服务FCFS             | 短作业优先SJF                                                | 高响应比算法HRRN                                             |
| ------------- | -------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 算法思想      | “公平”角度考虑             | 追求最少平均等待时间，平均周转时间..                         | 要综合考虑作业和进程的等待时间和要求服务的时间               |
| 算法规则      | 根据到达先后顺序考虑       | 最短的作业优先得到服务                                       | 每次调度的时候会计算每个作业/进程的响应比，选择响应比最高的作业/进程来为其服务 |
| 作业/进程调度 | 都可                       | 都可，SPF                                                    | 都可                                                         |
| 是否可抢占    | 否                         | SJF和SPF都是非抢占式，但SRTN是抢占式                         | 非抢占式                                                     |
| 优缺点        | 公平算法简单，对长作业有利 | 可得“最短”...时间但会产生饥饿现象                            | 综合考虑了相关因素                                           |
| 是否导致饥饿  | 不会                       | 会，如果有源源不断的短作业来，长作业甚至会“饿死”             | 不会                                                         |
| 备注          |                            | 在所有进程同时可运行时，SJF的平均等待时间平均周转时间最少；但在其他情况下不一定最短 |                                                              |

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200509081222685.png" alt="image-20200509081222685" style="zoom:67%;" />

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200509081859981.png" alt="image-20200509081859981" style="zoom:67%;" />

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200509082227265.png" alt="image-20200509082227265" style="zoom:67%;" />

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200509083405445.png" alt="image-20200509083405445" style="zoom:67%;" />

### ※调度算法——2※

> 注意点:1.算法思想 2.算法规则 3. 是作业调度还是进程调度 4.抢占式和非抢占式 5.优缺点 6.是否导致饥饿（作业长期得不到服务）

用在分时操作系统，更关注“响应时间”。

<font color="red">多用于</font>

|               | 时间片轮转RR                                                 | 优先级调度算法                                               | 多级反馈队列调度算法                                     |
| ------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | -------------------------------------------------------- |
| 算法思想      | 公平轮流的为进程服务，让每一个进程在一定时间间隔内得到响应   | 根据进程/作业的紧急程度来确定处理顺序                        | 对其他调度算法的折中权衡                                 |
| 算法规则      | 按照进程进入就绪队列的顺序，轮流地为进程执行一个时间片，如果未在一个时间片内执行完，则剥夺处理机将进程放到就绪队列程序排队 | 选取优先级高的先运行                                         |                                                          |
| 作业/进程调度 | 进程调度                                                     | 都可                                                         | 进程调度                                                 |
| 是否可抢占    | 抢占，由时钟中断控制CPU                                      | 都有                                                         | 抢占式                                                   |
| 优缺点        | 公平响应快适用于分时系统，不区分任务紧急情况                 | 可以根据紧急程度，重要程度灵活调整对各作业/进程的偏好程度；如果有源源不断的优先级较高的进程进入队列，会导致饥饿现象的发送 |                                                          |
| 是否导致饥饿  | 不会                                                         | 会                                                           | 会                                                       |
| 备注          | 如果时间片过大，就和变成FCFS算法。切换过于频繁也不行。涉及时间片切换开销时间占比不超过1% |                                                              | 设置多级优先级队列，各队列优先级从高到低，时间片从小到大 |

**优先级调度算法：**

非抢占式：

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200509091907443.png" alt="image-20200509091907443" style="zoom:67%;" />

抢占式：

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200509092236075.png" alt="image-20200509092236075" style="zoom:67%;" />

优先级分为两种：静态优先级和动态优先级。

通常：系统进程优先级高于用户进程；前台进程高于后台进程；更偏向于I/O繁忙型进程（能让I/O设备提前进入工作，使用效率提升）。

动态优先级什么时候应该调整：进程等待较长时间，应该适当提升优先级。

**多级反馈调度算法：**

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200509094904953.png" alt="image-20200509094904953" style="zoom:67%;" />

### 进程同步/互斥

**进程同步**：亦称直接制约关系。必须保证A步骤在B步骤之前执行。

**进程互斥**：分为进入区，临界区，退出区，剩余区。比如访问临界资源的时候的处理操作，进程互斥四原则。

四原则：1. 空闲让进  2. 忙则等待  3.  有限等待  4.让权等待

### 进程互斥的软件实现方法：

**单标志法**：将临界区的资源权限特定进程，其他进程访问时无效。主要问题是：当进程不访问临界区资源时候，却占用临界资源，违背“空闲让进”原则。

**双标志发**：设置bool型数组flag[]，表现各个标记各进程想要进入临界区的意愿。双标先检查法，双标后检查法。

先检查法：违反“忙则等待”，会发生两个进程（并发时候）都进入临界区的情况。

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200511135331583.png" alt="image-20200511135331583" style="zoom:67%;" />

后检查法：先上锁后检查，虽解决的了“忙则等待”，但违反了“空闲让进”和“优先等待”

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200511135529181.png" alt="image-20200511135529181" style="zoom:67%;" />

Peterson法：遵守了空闲让进，忙则等待，有限等待的原则，但未遵守让权等待：

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200511140328944.png" alt="image-20200511140328944" style="zoom:67%;" />

### 进程互斥的硬件实现方法

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200511141054460.png" alt="image-20200511141054460" style="zoom: 50%;" />

**中断屏蔽：**与原语实现方法类似。执行关中断指令直到程序执行完成。只适用于操作系统内核程序，不适于用户进程；并且不适用于多处理机，因为他只能中断自己的处理机。

**TS/TSL指令：**TestAndSet即首先检查临界资源是否上锁，如果上锁则一直等待，只等临界资源被解锁之后，当前程序再设置“上锁”，直到“一口气”运行完程序之后解锁。不满足“让权等待”。

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200511141854171.png" alt="image-20200511141854171" style="zoom:50%;" />

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200511141904239.png" alt="image-20200511141904239" style="zoom:50%;" />

**Swap指令：**用硬件实现的，执行过程不允许被中断，只能一气呵成。只是交换上锁状态和原状态，如果原状态也是上锁状态，则一直等待交换，和TSL差不多。

### ※信号量机制※：

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200511142627238.png" alt="image-20200511142627238" style="zoom: 33%;" />

以上7种算法都无法实现“让权等待”。所以信号量机制通过**原语**来对信号量进行操作。

信号量即一个变量，可以用数量表示某种资源的数量。

wait(S)和signal(S)原语简称PV操作，可分别作为P(S) V(S)。

一共有三种操作：初始化操作，P操作，V操作

wait：蹲一个打印机，如果没有打印机则一直蹲着，有则减一进入临界区。

**整形信号量：**

signal：释放一个资源，添加信号量

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200511143831543.png" alt="image-20200511143831543" style="zoom: 50%;" />

整形信号量存在的问题：不满足让权等待原则，会发生忙等。

**记录型信号量：**

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200511144354306.png" alt="image-20200511144354306" style="zoom:50%;" />

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200511144423957.png" alt="image-20200511144423957" style="zoom:50%;" />

当value值为负数时候表示此时有value的绝对值的数量在等待队列。

### 利用信号量实现进程的同步/互斥/前驱关系

**实现互斥**：

1. 分析活动，划定临界区

2. 设置互斥信号量mutex，设置为1，即进入临界区的名额

3. 在进入区P(mutex)——申请资源

4. 在退出区V(mutex)——释放资源

   <img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200511150716544.png" alt="image-20200511150716544" style="zoom:50%;" />

注意：1. 对于不同的临界资源设置不同的mutex 2. P、V操作必须成对出现

**实现同步：**让并发程序按要求顺序执行

1. 分析什么地方需要实现”同步关系“
2. 设置同步信号量S，设置为0
3. 在前操作之后执行V操作
4. 在后操作之前执行P操作

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200511151309138.png" alt="image-20200511151309138" style="zoom:50%;" />



**前驱关系**：

例：

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200511151502721.png" alt="image-20200511151502721" style="zoom:50%;" />

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200511151648303.png" alt="image-20200511151648303" style="zoom:67%;" />

### 生产者消费者问题

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200514081528739.png" alt="image-20200514081528739" style="zoom:67%;" />

P操作交换会产生死锁：

![image-20200514081854867](F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200514081854867.png)

V操作交换不会产生死锁。

### 多生产者和多消费者

![image-20200514083205523](F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200514083205523.png)

必须设置mutex变量，否则会导致数据被复写。

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200514083853103.png" alt="image-20200514083853103" style="zoom:67%;" />

### 吸烟者问题——可以生产多个产品的单生产者问题

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200514084852282.png" alt="image-20200514084852282" style="zoom:67%;" />

### 读者写者问题（听不懂）

读写两个进程并发执行，共享同一个文件。允许多个读进程同时进行读取文件，只允许一个写进程进行写信息。任一写程序在完成写操作之前不允许其他读者或者写程序进行操作。写程序执行写操作之前，应该让已有的读程序和写程序退出。

### 哲学家进餐——每个进程需要多个临界资源

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200514092924405.png" alt="image-20200514092924405" style="zoom:67%;" />

### 管程——更高级的互斥操作

> 信号量机制程序编写困难，容易出错，能不能不关注麻烦的PV操作？

<font color="green">就相当于系统给你都包含一些细节了，自己编程的时候就不需要管PV操作了</font>

管程的组成：

1. 局部于管程的共享数据结构说明
2. 对数据结构进行操作的一组过程（相当于“函数”）
3. 可以设置初始化语句
4. 有一个名字

基本特征：

1. 局部于管程的数据只能被局部于管程的过程所访问。
2. 一个进程只有通过调用管程的过程才能进入管程访问共享数据。
3. 每次仅允许一个进程在管程内执行某个内部过程

由编译器就实现了，只要调用对应管程的函数就可以了

### 死锁

> 互相等待**互斥**资源导致进程一直阻塞无法前进的现象

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200516102536316.png" alt="image-20200516102536316" style="zoom:67%;" />

死锁产生的条件：互斥条件和不剥夺条件，循环等待条件：<font color="red">循环等待未必死锁，死锁一定循环等待</font>

如何产生死锁：

1. 对系统资源的竞争
2. 进程推进的顺序非法
3. 对信号量的使用不当

处理策略：

1. 预防死锁
2. 避免死锁
3. 死锁检测和解除

### 预防死锁

> 稍微记忆

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200516104221289.png" alt="image-20200516104221289" style="zoom: 33%;" />

1. 破坏互斥条件：

   SPOOLing技术

2. 破坏不剥夺条件

   

3. 破坏请求和保持条件

   <img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200516105157747.png" alt="image-20200516105157747" style="zoom:50%;" />

4. 破坏循环等待条件

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200516105547730.png" alt="image-20200516105547730" style="zoom:50%;" />

### 避免死锁（银行家算法）

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200516105800370.png" alt="image-20200516105800370" style="zoom:33%;" />

预先判断

状态：

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200516111443520.png" alt="image-20200516111443520" style="zoom: 50%;" />

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200516111615021.png" alt="image-20200516111615021" style="zoom: 33%;" />

快速计算：

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200516111718986.png" alt="image-20200516111718986" style="zoom:50%;" />

步骤：

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200516112126717.png" alt="image-20200516112126717" style="zoom:50%;" />

### 死锁的检测和解除

检测：

分为请求边和分配边：请求边是指进程对资源的请求；分配边是指资源已经分配给进程的资源。

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200620101508948.png" alt="image-20200620101508948" style="zoom:50%;" />

如果可完全简化，则无死锁。

阻塞的情况：

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200620101637996.png" alt="image-20200620101637996" style="zoom:67%;" />

使用资源分配图，如果化简最后可以化为孤立的节点，则不是死锁。

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200516114512421.png" alt="image-20200516114512421" style="zoom:50%;" />

解除死锁：

1. 资源剥夺法：挂起死锁进程，抢占资源，并防止饥饿现象。
2. 撤销进程法：简单粗暴，代价很大
3. 进程回退法：设置还原点，记录历史信息。

> 考虑优先级，运行时间，还有多长运行完成，已经使用了多少资源，交互式还是批处理

## 内存管理

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200521182851452.png" alt="image-20200521182851452" style="zoom:33%;" />

> 操作系统负责内存空间的分配与回收

内存：程序放到内存里才能被CPU处理。

地址转换：动态运行时装入（现代操作系统），可重定位装入（早期多道批处理）

### 内存空间的扩充

**覆盖**：将程序分为多个段，常用的放在固定区，**不常用不会同时访问**的的放在覆盖区。

缺点：必须由程序员声明覆盖结构，对用户不透明，增加编程负担。

**交换**：又称对换。内存紧张时，系统将内存中某些进程换出外存，把外存中的已具备条件的进程换入内存。（中级调度）

放到外存什么位置呢？磁盘存储空间的对换区（连续分配空间方式）。

什么时候交换？内存吃紧的时候，缺页率升高

应该换出什么进程呢？处于阻塞状态的进程，优先级低的进程（考虑进程的驻留时间）

<font color='red'>PCB始终在常驻内存中</font>

#### 虚拟内存

传统存储管理的缺点：一次性，驻留性

根据局部性原理设计的：时间局部性，空间局部性

特性：多次性，对换性，虚拟性（表现出来的要大）

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200601130447707.png" alt="image-20200601130447707" style="zoom:50%;" />



请求分页存储管理 与 基本分页存储管理：

1. 判断是否在内存，从外存调入主存
2. 置换功能

**请求分页**存储管理：

过程：

当程序中所访问的内容不在内存中的时候，产生缺页中断（内中断），等待页面装入内存，如果内存中有空闲块，则分配空闲块，如果没有需要通过置换算法淘汰一个页面换下来。

#### 置换算法

OPT置换算法：淘汰以后都不会使用的或者最长不再被访问的页面（但无法实现）

FIFO算法：略

LRU算法：学过，略（性能好，开销大）

时钟置换算法：

简单CLOCK：

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200601140246947.png" alt="image-20200601140246947" style="zoom:50%;" />

#### 页面分配策略

驻留集：请求分页存储管理给进程分配的物理块大小

固定分配和可变分配。

局部置换和全局置换（置换的是不是自己的）

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200601151041783.png" alt="image-20200601151041783" style="zoom: 50%;" />



<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200601151344311.png" alt="image-20200601151344311" style="zoom:50%;" />

何时调入页面：

2. 请求调页策略：运行时调度I/O调度

何处调入页面：

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200601160918743.png" alt="image-20200601160918743" style="zoom:67%;" />

**抖动**（颠簸）：

刚刚换出内存立马换入内存，刚换入就换出。分配进程的物理块太少。

工作集：

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200601161217431.png" alt="image-20200601161217431" style="zoom:67%;" />

### 内存空间的分配与回收

### 连续分配方式：

1. 单一连续分配：内存分为系统区和用户区。内存中**只能**有一个用户程序。

   实现简单，无外部碎片。不太需要内存保护。只能用于单用户、单任务系统，有内部碎片利用率低

2. 固定分区分配：支持多道程序，程序之间不会互相干扰。分为分区大小相等和分区大小不等的情况。前者缺少灵活性，后者无外部碎片，有内部碎片利用率低

3. 动态分区分配：动态分配。

内部碎片：分配给某个进程的区域中，有些内存没有用上。

外部碎片：内存中某些空闲区域由于太小而导致无法利用

可以使用“紧凑”来解决外部碎片问题。

#### **动态分区分配算法**

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200523083121285.png" alt="image-20200523083121285" style="zoom:50%;" />

1. 首次适应算法：每次从低地址开始查找。空闲分区从地址递增次序排列。找到大小满足的第一个空闲分区。
2. 最佳适应算法：按照**容量**递增次序链接。顺序查找第一个符合要求。会产生很多**外部碎片**。
3. 最坏适应算法：按照**容量**递减次序链接。优先使用最大的。之后“大进程”就无法运行了
4. 邻近适应算法：解决首次适应算法每次都是从链头查找的问题，会导致低地址出现很多很小的空闲分区。排列同FT，每次从上次查找结束的位置开始查找空闲分区（可使用循环链表）。

反而首次适应算法是最好的。

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200523084452028.png" alt="image-20200523084452028" style="zoom:67%;" />

### 非连续分配管理方式：

#### ※基本分页存储管理※

系统把内存分为一个个大小相同的分区（每个分区40KB），每个分区就是一个“页框”（内存块=物理块=物理页面），每个页框有个编号，称为“页框号”（物理块号=物理页号）。

进程的**页面**和**内存**的页框是一一对应的。各个页面不必连续存放。页面的大小最好是2的整数次幂。

**页表**：一个进程对应一张页表。每个页面对应一个页表项，每个页表项由页面和块号组成。页表记录着进程页面和实际存放内存块之间的映射关系。

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200523085947844.png" alt="image-20200523085947844" style="zoom:50%;" />

页号不占用地址，是隐含的。

如何实现地址转换？物理地址=起始地址+页面偏移量

#### ※基本地址变化机构※

> 两次访问内存。查页 和 访问内存单元

设置一个页表寄存器（PTR）存放页表的起始地址F和页表长度M，未执行的时候放在PCB中，执行的时候放在PTR中。

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200523095547675.png" alt="image-20200523095547675" style="zoom:50%;" />

<font color='red'>题目：</font>

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200523100411894.png" alt="image-20200523100411894" style="zoom:50%;" />



**具有快表的地址变换机构(TLB)：**

用于存放最近访问的页表项的副本。内存中的页表常称为慢表。

能否把整个页表都存放在TLB中呢?因为快表贵啊。

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200527153243379.png" alt="image-20200527153243379" style="zoom:67%;" />



**两级页表**：

> 单级页表存在：1. 页表必须连续存放，因此页表很大时，需要占用多个连续的页框。没必要让整个页表常驻页面，因为进程在一段时间内只需要访问几个特定的界面。

可以将长长的页表进行分组，使每个内存块刚好放入一个分组。再将这些离散分配的页表再创建一个页表，称为页目录表（外层页表）

<font color='red'>题目：</font>

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200527161022999.png" alt="image-20200527161022999" style="zoom:67%;" />

n级页表需要访问n+1次

#### 基本分段存储管理

程序会按照自身的逻辑关系分为若干个段，每个段都有一个段名。每个段在内存中占据连续的空间，但各段之间可以不相邻。

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200527162227769.png" alt="image-20200527162227769" style="zoom:67%;" />

段表：记录每个段在内存中的起始位置和大小。

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200527162538807.png" alt="image-20200527162538807" style="zoom:67%;" />

#### 分段和分页的区别

> 分段比分页更容易实现信息的共享和保护

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200527163215860.png" alt="image-20200527163215860" style="zoom:67%;" />

#### 段页式存储管理方式

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200527164918676.png" alt="image-20200527164918676" style="zoom:67%;" />

先分段，再分页。

因此，段页式系统的逻辑地址由**段号、页号、页面偏移地址**组成。

## 文件管理

文件的属性：文件名，标识符，类型，位置，创建时间，文件修改时间等

文件的分类：有结构文件，无结构文件

功能：文件共享，文件保护

### 文件的逻辑结构

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200604084431588.png" alt="image-20200604084431588" style="zoom:67%;" />

无结构文件：

**有结构文件**：

由相似的记录组成。每个数据项叫做**关键字**

顺序文件：串结构（与关键字无关）和顺序结构

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200604084844040.png" alt="image-20200604084844040" style="zoom: 50%;" />

索引文件：解决可变长记录不可随机存取的问题。使用**指针**

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200604085020545.png" alt="image-20200604085020545" style="zoom:50%;" />

索引顺序文件：多级索引顺序表

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200604085341451.png" alt="image-20200604085341451" style="zoom:67%;" />

### 文件目录

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200604085537763.png" alt="image-20200604085537763" style="zoom:50%;" />

文件控制块FCB：存储文件的一条一条的记录。

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200604085721540.png" alt="image-20200604085721540" style="zoom:67%;" />

**目录结构：**

单级目录：不允许重名

两级文件目录：用户不可以把自己文件分类

多级文件目录：

有向无环图：实现文件共享。删除的时候，共享计数器减1

![image-20200604090311889](F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200604090311889.png)

什么是索引节点：

### 文件的物理结构

对空闲磁盘和非空闲磁盘管理

连续分配：

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200604091315994.png" alt="image-20200604091315994" style="zoom:50%;" />

链接分配：

隐式链接：利用率高

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200604091707185.png" alt="image-20200604091707185" style="zoom:50%;" />

显示连接：

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200604091839601.png" alt="image-20200604091839601" style="zoom:50%;" />

索引分配：

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200604092419306.png" alt="image-20200604092419306" style="zoom:67%;" />

多级索引

![image-20200604092903591](F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200604092903591.png)

K层访问K+1次磁盘

混合索引：

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200604093143004.png" alt="image-20200604093143004" style="zoom:50%;" />

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200604093401317.png" alt="image-20200604093401317" style="zoom:67%;" />

各种分配方式对比：

![image-20200604093318461](F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200604093318461.png)

### 文件存储空间管理（磁盘空间管理）

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200605100315904.png" alt="image-20200605100315904" style="zoom:50%;" />

用什么方法组织、记录空闲块；如何分配磁盘块；如何回收磁盘块

**空间划分和初始化**：

划分：分为不同的磁盘卷

初始化：文件划分为目录区和文件区

管理方法:

空闲表法：使用连续分配。和内存的连续分配表类似

空闲链表法：分为空闲盘块链和空闲盘区链（指向下一个盘区的指针）

位视图法：

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200605101709036.png" alt="image-20200605101709036" style="zoom:67%;" />

成组链接法：空闲表和链表不适合大型文件系统。理解即可。

文件卷的目录区会设置“超级块”，系统启动时将超级块渡人内存。

### 文件的基本操作

创建文件：路径，文件名。操作系统在外存找到文件所需的空间；在对应目录项创建该文件。

删除文件：路径，文件名。操作系统找到对应的目录项，回收文件占用的磁盘块，删除目录表。

打开文件：路径，文件名，操作类型。找到对应的目录项，将文件复制到内存中，然后操作。进程的打开文件表中。

关闭文件：删除进程对应的打开文件表表项，系统的打开文件表计数器-1.

读文件：先打开文件，读入文件多少数据。

### 文件共享

共享≠复制

硬链接：基于索引节点

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200605112739071.png" alt="image-20200605112739071" style="zoom:67%;" />

软链接：相当于“快捷方式”

### 文件保护

口令保护：设置口令

加密保护：需要一定时间

访问控制：设置操作权限

### 文件系统结构

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200605133617062.png" alt="image-20200605133617062" style="zoom:67%;" />

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200605133732234.png" alt="image-20200605133732234" style="zoom:67%;" />

### 磁盘的结构

### 磁盘调度算法

FCFS先来先服务：

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200605155424469.png" alt="image-20200605155424469" style="zoom:67%;" />

**SSTF最短寻找时间优先算法**（贪心算法，当前最优，总体未必最优）：优先找离当前磁头最近的请求

但是会产生“饥饿”现象

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200622155945585.png" alt="image-20200622155945585" style="zoom:67%;" />

**扫描算法SCAN**：只有移到最外才能向内寻找，只有移到最内才能向外寻找。（电梯算法）

缺点：特点即缺点；响应不均

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200622160904312.png" alt="image-20200622160904312" style="zoom:67%;" />

**LOOK调度算法：**SCAN算法不必移动到磁盘边缘

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200622161007757.png" alt="image-20200622161007757" style="zoom:67%;" />

**C-SCAN算法**：SCAN算法基础上，移动到边缘的时候立即回到起点，不是往返式。

**C-LOOK算法**：LOOK算法的类似C-SCAN算法。

### 减少磁盘延迟时间的方法

1. 交替编号

2. 错位命名：

   ![image-20200605161601297](F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200605161601297.png)

### 磁盘管理

初始块，坏块。

# 操作系统习题

## 进程管理

### 求周转时间

非抢占式：

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200618090451934.png" alt="image-20200618090451934" style="zoom: 80%;" />

### 进程调度

#### 抢占式和非抢占式

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200618090551153.png" alt="image-20200618090551153" style="zoom: 80%;" />

进程示意图如下：

1. 非抢占式

   <img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200618092747449.png" alt="image-20200618092747449" style="zoom: 50%;" />

   

2. 抢占式

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200618095227223.png" alt="image-20200618095227223" style="zoom: 50%;" />

#### 进程调度，平均等待时间

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200618100022201.png" alt="image-20200618100022201" style="zoom: 67%;" />

解：

(1). FCFS：p1,p2,p3,p4,p5		优先级：p1, p4, p3, p5, p2

(2). 非抢占平均等待时间=9.6

抢占式平均等待时间：

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200618105028337.png" alt="image-20200618105028337" style="zoom:67%;" />

---

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200630195127469.png" alt="image-20200630195127469" style="zoom:80%;" />

---

HRNN：

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200630200343463.png" alt="image-20200630200343463" style="zoom:80%;" />

#### 作业调度

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200619213216182.png" alt="image-20200619213216182" style="zoom: 67%;" />

需要根据主存容量来确定作业是否能抢占得到主存。

```
10:00 1号进入内存，开始计算，主存剩余85K，磁带机剩余2台
10:20 2号进入内存，作业时间较长，不抢占，等待处理机处理
10:25 1号处理完毕，2号开始计算，主存剩余40K，磁带机剩余3台
10:30 3号入井，内存不足50K，无法抢占
10:35 4号入井，内存和磁带机充足，抢占处理机，内存剩余30K，磁带机剩余1台
10:40 5号入井，磁带机不足，无法抢占
10:55 4号运行完毕，内存剩余40K，磁带机剩余3台，3号优先级最高但内存不足无法分配，交给2号继续
11:15 2号运行完毕，3号比5号优先级高，3号运行，剩余内存50K，磁带机剩余1台
11:25 3号运行完毕，5号开始运行
11:40 5号运行完毕
1号周转：25
2号周转：15+40 = 55
3号周转：30+25 = 55
4号周转：20
5号周转：40+20 = 60
平均周转：(25+55+60+20+60)/5=43
```

#### RAG图化简（资源分配图）

> 绿色表示已分配的资源，蓝色表示请求资源

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200620102725734.png" alt="image-20200620102725734" style="zoom:33%;" /><img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200620102757323.png" alt="image-20200620102757323" style="zoom:33%;" /><img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200620103116334.png" alt="image-20200620103116334" style="zoom:33%;" />

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200620103145833.png" alt="image-20200620103145833" style="zoom:33%;" />

#### 银行家算法

> 找一个安全序列

| 进程 | 最大需求 <br/>ABCD | 已占资源<br/>ABCD | 需要资源 |
| :--: | :----------------: | :---------------: | :------: |
|  P1  |        0013        |       0012        |   0001   |
|  P2  |        1750        |       1000        |   0750   |
|  P3  |        2356        |       1354        |   1002   |
|  P4  |        0652        |       0632        |   0020   |
|  P5  |        0656        |       0014        |   0642   |

现在系统还剩资源 A 类 1 个，B 类 5 个，C 类 2 个和 D 类 0 个，请按银行家算法回答下列问题：

（1）现在系统是否处于安全状态？给出解释。

```
剩余资源1520

安全序列：P4(1 11 5 2)，P1，P2，P3，P5
```

（2）如果现在进程 P2 提出需要（0，4，2，0）个资源的请求，系统能否去满足它，为什么？

分配给P2之后：

| 进程 | 最大需求<br/>ABCD | 已占资源<br/>ABCD | 需要资源 |
| :--: | :---------------: | :---------------: | :------: |
|  P1  |       0013        |       0012        |   0001   |
|  P2  |       1750        |       1420        |   0330   |
|  P3  |       2356        |       1354        |   1002   |
|  P4  |       0652        |       0632        |   0020   |
|  P5  |       0656        |       0014        |   0642   |

1520 -> 1100，1100 不能满足任何一个程序，因此会死锁。

## 内存管理

### 逻辑到物理地址转换

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200523100411894-1627968823433.png" alt="image-20200523100411894" style="zoom:50%;" />

```
2500/1024=2			2500%1024=452
2没有越界  且 2 → 8
物理地址：8 * 1024 + 425 = 8644
```

---

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200621103350556.png" alt="image-20200621103350556" style="zoom: 100%;" />

```
1011 / 1024 = 0  1011 % 1024 = 1011  0 → 2   2*1024 + 1011 = 3059
2148 / 1024 = 2  2148 % 1024 = 100   2 → 1   1*1024 + 100 = 1124
4000 / 1024 = 3  4000 % 1024 = 928   3 → 6   6*1024 + 928 = 7072
5012 / 1024 = 4  超过页表长度，地址不存在
```

### 置换算法

![image-20200621100938862](F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200621100938862.png)

FIFO：

|      | 2    | 1    | 5    | 6    | 2    | 1    | 2    | 3    | 7    | 6    | 3    | 2    | 1    | 2    | 3    | 6    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1    | 1    | 1    | 2    | 3    | 4    | 5    | 5    | 6    | 2    | 1    | 1    | 3    | 7    | 7    | 6    | 6    |
| 2    | 2    | 2    | 3    | 4    | 5    | 6    | 6    | 2    | 1    | 3    | 3    | 7    | 6    | 6    | 2    | 2    |
| 3    | 3    | 3    | 4    | 5    | 6    | 2    | 2    | 1    | 3    | 7    | 7    | 6    | 2    | 2    | 1    | 1    |
| 4    | 4    | 4    | 5    | 6    | 2    | 1    | 1    | 3    | 7    | 6    | 6    | 2    | 1    | 1    | 3    | 3    |
|      |      |      | √    | √    | √    | √    |      | √    | √    | √    |      | √    | √    |      | √    |      |

淘汰顺序：1，2，3，4，5，6，2，1，3，7

缺页次数：10次

最后驻留：6213

LRU：

|      | 2    | 1    | 5    | 6    | 2    | 1    | 2    | 3    | 7    | 6    | 3    | 2    | 1    | 2    | 3    | 6    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1    | 1    | 3    | 4    | 2    | 1    | 5    | 5    | 6    | 1    | 2    | 2    | 7    | 6    | 6    | 6    | 1    |
| 2    | 3    | 4    | 2    | 1    | 5    | 6    | 6    | 1    | 2    | 3    | 7    | 6    | 3    | 3    | 1    | 2    |
| 3    | 4    | 2    | 1    | 5    | 6    | 2    | 1    | 2    | 3    | 7    | 6    | 3    | 2    | 1    | 2    | 3    |
| 4    | 2    | 1    | 5    | 6    | 2    | 1    | 2    | 3    | 7    | 6    | 3    | 2    | 1    | 2    | 3    | 6    |
|      |      |      | √    | √    |      |      |      | √    | √    | √    |      |      | √    |      |      |      |

淘汰顺序：3，4，5，6，1，7

缺页次数：6次

最后驻留：1236

---

![image-20200621120445447](F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200621120445447.png)

```
页号：1 2 1 0 4 1 3 4 2 1
```

FIFO：

| 1    | 2    | 1    | 0    | 4    | 1    | 3    | 4    | 2    | 1    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | 0    | 0    | 0    | 1    | 1    | 2    | 2    | 2    | 4    |
| 1    | 1    | 1    | 1    | 2    | 2    | 4    | 4    | 4    | 3    |
|      | 2    | 2    | 2    | 4    | 4    | 3    | 3    | 3    | 1    |
| √    | √    |      |      | √    |      | √    |      |      | √    |

缺页中断次数：5	淘汰率：30%    中断率：1/2   淘汰顺序：0，1，2

LRU：

| 1    | 2    | 1    | 0    | 4    | 1    | 3    | 4    | 2    | 1    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | 0    | 0    | 2    | 1    | 0    | 4    | 1    | 3    | 4    |
| 1    | 1    | 2    | 1    | 0    | 4    | 1    | 3    | 4    | 2    |
|      | 2    | 1    | 0    | 4    | 1    | 3    | 4    | 2    | 1    |
| √    | √    |      |      | √    |      | √    |      | √    | √    |

缺页中断次数：6 	淘汰顺序：2，0，1，3    中断率：60%

### 内存分配方式（连续和非连续）

#### 可变分区方式（连续）

![image-20200621120251578](F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200621120251578.png)

```
最先适应不可以（理由）
J4 J1 J2 J3 J5
```

#### 页式存储

![image-20200622143656592](F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200622143656592.png)

$$
2*2^{20}÷2^9÷2^5 = 128字数\\
2999/32=93字....23号\\
99*32 + 19 +1 =3188
$$

---

某系统采用页式存储管理策略，拥有逻辑空间 32 页，每页 2KB，拥有物理空间 1MB。

（1）写出逻辑地址格式。 

（2）若不考虑访问权限，进程的页表有多少项？每项至少有多少位？ 

（3）如果物理空间减少一半，页表结构应相应作怎样的调整？

```
（1）页号5位  页内地址11位
（2）2^20 / 2^11 = 2^9
（3）如果物理空间减少一半，则页表中页表项数仍不变，但每项的长度可减少 1 位。

```

---

假定某页式管理系统，主存为 64KB，分成 16 块，块号为 0、1、2……15。设某作业有 4 页，其页号为 0、1、2、3，被分别装入主存的 2、4、1、6 块，试问：

（1）该作业的总长度是多少字节？（按十进制）

```
64KB / 16 = 4 KB
4KB *4 = 16 KB
```

（2）写出该作业每一页在主存中的起始地址。

```
2 * 4K = 8K
4 * 4K = 16K
1 * 4K = 4K
6 * 4K = 24K
```

（3）给出逻辑 地址[ 0，100]、[ 1，50] [ 2，0] [ 3，60]，请计算相应的内存地址。

```
2*4K+100=8292
4*4K+50 =16434
1*4K+0 = 4096
6*4K + 60 = 24636
```

### 页式虚拟存储

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200630205856111.png" alt="image-20200630205856111" style="zoom:80%;" />

```
5ms = 5000μs
```



## 文件管理

### 磁盘调度算法

![image-20200622163413521](F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200622163413521.png)

---

[另一道题 P56 4T](F:/课程及作业/重要的课/操作系统/江南大学操作系统复习提纲.pdf)

---

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200630202900246.png" alt="image-20200630202900246" style="zoom:80%;" />

### 位视图

<img src="F:\课程及作业\重要的课\操作系统\操作系统笔记.assets\image-20200622170928408.png" alt="image-20200622170928408" style="zoom:67%;" />