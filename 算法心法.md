# Algorithm

## 前言

### 刷题网站：

* Leetcode：[Leetcode](https://leetcode-cn.com/problemset/algorithms/)
* acwing：[acwing](https://www.acwing.com/)
* 剑指Offer：[剑指Offer link](https://leetcode-cn.com/problem-list/xb9nqhhg/)
* 牛客网：[牛客网](https://www.nowcoder.com/exam/oj)

## 一. 数组与链表

### 1. 有环链表

🔵如何判断链表有环：

<img src="算法心法.assets/168178e06e2b0f1729f77522d3440c4.jpg" alt="168178e06e2b0f1729f77522d3440c4" style="zoom: 40%;" />

龟兔赛跑算法（快慢指针）：

刚开始指针A和指针B指向链表头，A每向前走一步，B就向前走两步。

如果无环，B会首先变成null空指针，B指针不可能追上A。

当B距离A有1个距离时，下一次迭代两者一定会相遇。

当B距离A有2个距离的时候，经过一次迭代就会变成第一种情况，因此一定会相遇。

**结论**：只要两者在环中，最后都一定会相遇。

🔵如何确定有环链表的起点：

由上面结论可推，当将环中的起点断开为链表的时候，在链表前半段的时候A不可能追上B，在后半段的时候根据初中数学之后可得两者最终在终点才能相遇，因此可得A与B每次相遇的地点都相同。

当第一次相遇的时候开始记录，第二次相遇的时候记录A走过的距离为 $K$ ，即得环的长度 $K$。

<img src="算法心法.assets/d5366ab77a944e857bcf091dca4685c.jpg" alt="d5366ab77a944e857bcf091dca4685c" style="zoom:50%;" />

由于环的长度为 $K$，设链表的长度为 $m$，因此让A和B同时回到链表起点，先让B走K步；然后A和B同时出发，当B指针与A指针相遇时，即可得到环头。

### 2. 双指针

题目：

* [三数之和](https://leetcode-cn.com/problems/3sum/)
* [最接近的三数之和](https://leetcode-cn.com/problems/3sum-closest/)
* [日志统计](https://www.acwing.com/problem/content/1240/)
* [11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)

### 3. 前缀和与差分数组

题目：

* [前缀和 (模板)](https://www.acwing.com/problem/content/797/)
* [子矩阵的和 (模板)](https://www.acwing.com/problem/content/798/)
* [差分 (模板)](https://www.acwing.com/problem/content/799/)
* [差分矩阵 (模板)](https://www.acwing.com/problem/content/800/)

🔵前缀和：

查询一个数组中间某段序列的和。

欲求$\displaystyle\sum_{i=l}^ra[i]$，设$S[j]=\displaystyle\sum_{i=0}^ja[i]$，则$\displaystyle\sum_{i=l}^ra[i]=S[r]-S[l-1]$。

扩展二维矩阵和。

<img src="算法心法.assets/c0fb61ece5e6adddf0932f33f547b22.jpg" alt="c0fb61ece5e6adddf0932f33f547b22" style="zoom:50%;" />

A区域之和=$S[i][j]-s[a][j]-s[i][b]+s[a][b]$

🔵差分矩阵

对于一个数组，要对中间 $[l,r]$ 都加上某个常数$c$，然后求最终的序列。

思想：利用前缀和的逆思想。对于原数组$a[i]$中加某个常数$c$，其对应的前缀和数组$s[i:n]$都需要加上C。因此可以利用这种逆思想将对应的数组看成前缀和数组，前缀和中的原数组即为差分数组。

构造差分数组的公式：$c[i]=a[i]-a[i-1]$，若要对区间 $[l,r]$ 都要加上某个常数C，则只需要 $c[l]+c$，$c[r+1]-c$即可，最终汇总数组 $c$ 的前缀和数组即可得到最终的序列。时间复杂度由原来的 $O(n^2)$ 将为了 $O(n)$。

### 4. 链表的数组表示法

题目：

* [单链表](https://www.acwing.com/problem/content/828/)

一般情况下对于链表的表示方法都是使用结构体的形式，创建的时候采用的是new的方法。然而这种方式对于数据量较大的情况就寄了，会导致TLE等情况，因此需要更加快速的方法来创建数组。

这里采用数组的方式来进行表示链表，用 $e[n]$ 存储链表中的信息，$en[n]$ 表示链表中对应下一个节点的索引。

## 二. 堆栈队列

### 1. hint

对于堆和队列两种数据结构，其操作只涉及到头和尾，因此对于已经有头和尾指针的情况下，就无需进行其他多余操作。

例题：[剑指 Offer 09. 用两个栈实现队列](https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/)

### 2. 单调栈

例题：
* [42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)
* [84. 柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)
* [316. 去除重复字母](https://leetcode-cn.com/problems/remove-duplicate-letters/)

即维持一个单调递增或者递减的栈，新加入的元素比栈顶元素小(大)。

模板（单调不增栈）：

```java
public int monotonicStack(int[] height) {
    if (height.length <= 2) return 0;
    Stack<Integer> stack = new Stack<>();
    int ans = 0;
    stack.push(0);
    int i = 1;
    while (i < height.length) {
        while (!stack.empty() && height[i] > height[stack.peek()]) {
            Integer pop = stack.pop();
            if (!stack.empty()) {
                // 处理逻辑
                int h = Math.min(height[i], height[stack.peek()]) - height[pop];
                ans += h * (i - stack.peek() - 1);
            }
        }
        stack.push(i++);
    }
    return ans;
}
```

### 3. 滑动窗口

例题：

* [无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

滑动窗口可以用来解决序列或者数组中的循环问题，可以将嵌套循环问题转换为单循环问题，降低时间复杂度。滑动窗口也可以看作是一个队列，只涉及到数据某段序列的头和尾操作。

## 三. 树和森林

### 1. 树状数组和线段树

题目：

* [1264. 动态求连续区间和 (模板)](https://www.acwing.com/problem/content/1266/)

应用于单点修改和区间查询，时间复杂度为 $O(\log n)$

🔵树状数组

* $O(\log n)$快速求前缀和。
* 在某个位置的数，加上一个数

![image-20220223162823400](算法心法.assets/image-20220223162823400.png)

树状数组的层数是有对应位置数字二进制末尾几个零决定。

树状数组有三个必要操作：`lowbit(x), add(), query()`，分别表示特定计算，对某个元素添加一个值以及查询前缀和。其中$\text{lowbit(x)}=x\&-x$。其查询前缀和以及进去区间修改的时间复杂度为$O(\log n)$

求位置索引`x`之前序列前缀和：

```c
for(int i=x;i>0;i-=lowbit(i))res+=c[i];
```

在位置索引`x`添加数值`v`后需要进行的序列修改：

```c
for(int i = x; i <= n; i += lowbit(x))c[i]+=v;
```

模板：

```c++
#include "iostream"
#include "cstdio"
#include "algorithm"

using namespace std;

typedef long long ll;

const int N = 100010;
int n, m;
int tr[N];

int lowbit(int x) {
    return x & -x;
}

void add(int t, int x) {
    for (int i = t; i <= n; i += lowbit(i)) tr[i] += x;
}

ll query(int t) {
    ll ans = 0;
    for (int i = t; i > 0; i -= lowbit(i)) {
        ans += tr[i];
    }
    return ans;
}

int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; ++i) {
        int item;
        scanf("%d", &item);
        add(i, item);
    }
    int k, a, b;
    while (m--) {
        scanf("%d%d%d", &k, &a, &b);
        if (k) add(a, b);
        else cout << query(b) - query(a - 1) << endl;
    }
}
```

🔵线段树

![img](算法心法.assets/线段树表示.png)

其维持的就是结构体数组，结构体中记录数组的边界和所保存的值。

基础线段树有四个操作：`pushup()`根据子节点的信息来更新父节点，`build()`构造线段树，`modify()`单点修改，`query()`区间查询。

模板：

```c++
#include "cstdio"

const int N = 100010;
int arr[N];
struct Node {
    int l, r;
    int sum;
} tr[N * 4 + 1];
int n, m;

void pushup(int u) {
    tr[u].sum = tr[u << 1].sum + tr[u << 1 | 1].sum;
}

void build(int u, int l, int r) {
    if (l == r) tr[u] = {l, r, arr[l]};
    else {
        tr[u] = {l, r};
        int mid = l + r >> 1;
        build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
        pushup(u);
    }
}

void modify(int u, int t, int x) {
    if (tr[u].l == tr[u].r)tr[u].sum += x;
    else {
        int mid = tr[u].l + tr[u].r >> 1;
        if (t <= mid) modify(u << 1, t, x);
        else modify(u << 1 | 1, t, x);
        pushup(u);
    }
}

int query(int u, int l, int r) {
    if (tr[u].l >= l && tr[u].r <= r)return tr[u].sum;
    int mid = tr[u].l + tr[u].r >> 1;
    int sum = 0;
    if (l <= mid) sum = query(u << 1, l, r);
    if (r > mid) sum += query(u << 1 | 1, l, r);
    return sum;
}

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; ++i) scanf("%d", &arr[i]);
    build(1, 1, n);
    int k, a, b;
    for (int i = 0; i < m; ++i) {
        scanf("%d%d%d", &k, &a, &b);
        if (k) modify(1, a, b);
        else printf("%d\n", query(1, a, b));
    }
}
```

### 2. 树的直径(wait)

例题：[1207. 大臣的旅费](https://www.acwing.com/problem/content/1209/)

## 四. 图论



## 五. 递归分治

### 1. 二分思想

题目：

* [789. 数的范围 (模板题)](https://www.acwing.com/problem/content/791/)

思想：

1. 确定一个区间，使得答案一定在区间内。
2. 找一个性质满足两点：
   * 性质具有二段性，前段满足条件，后段不满足条件
   * 答案是具有分界点的

比如整数二分。

找区间左端点时：$\text{mid}=\dfrac{l+r}{2}$，找区间右端点的时候：$\text{mid}=\dfrac{l+r+1}{2}$

因为对于奇数除以2的时候默认向下取整。因此找左端点的时候默认端点靠左，找右端点的时候计算mid时候需要加一，让右端点的范围更加靠右。

```c
#include<cstdio>
#include<cstring>

int n, q;

int s[100010];

int main(){
	scanf("%d%d", &n, &q);
	for(int i=0;i<n;i++)scanf("%d", &s[i]);
	for(int i = 0; i < q; i ++){
		int t;
		scanf("%d", &t);
		
		int l = 0, r = n - 1;
		while(l < r){		// 找左端点
			int mid = l + r >> 1;
			if(s[mid] >= t) r = mid;
			else l = mid + 1;
		}
		
		if(s[r] == t){
			printf("%d ", r);
			r = n - 1;
			while(l < r){	// 找右端点
				int mid = l + r + 1 >> 1; // l = mid +1向上取整
				if(s[mid] <= t) l = mid;
				else r = mid - 1;
			}
			printf("%d\n", r);
		}else{
			printf("-1 -1\n");
		}
	} 
	return 0;
}
```

### 2. 全排列

```c
void permutation(int *a, int low, int high){
    if(low==high){
        for (int i = 0; i <= high; ++i) printf("%d ",a[i]);
        printf("\n");
    }else{
        for (int i = low; i <= high; ++i) {
            swap(&a[low],&a[i]);
            permutation(a,low +1, high);
            swap(&a[low],&a[i]);	//再换回来
        }
    }
}
```

### 3. 下一个字典序

例题：[31. 下一个排列](https://leetcode-cn.com/problems/next-permutation/)

步骤一：由排列计算出字典序值：

设给定的$\{1,2,...,n\}$的排列为 $\pi$ ，设其字典序的值为 $\text{rank}(\pi,n)$，那么其对应的字典序值显然存在：
$$
(\pi[1]-1)\cdot(n-1)!\le \text{rank}(\pi,n)\le \pi[1]\cdot(n-1)!-1
$$
设 $r$ 为 $\pi$ 在以$\pi[1]$ 开头的所有排列中的序号，那么就可以得到 $r$ 也是集合 $\{1,2,...,n\}-\{\pi[1]\}$ 中序列为 $[\pi[2],\pi[3]],...\pi[n]$ 的序号。那么将 $\pi$ 中所有大于 $\pi[1]$ 的元素都减一就会得到集合$\{1,2,...,n-1\}$的排列 $\pi'$，其字典序也是 $r$ ，由此就得到计算$\text{rank}(\pi,n)$的递归公式：
$$
\text{rank}(\pi,n)=(\pi[1]-1)\cdot(n-1)!+\text{rank}(\pi',n-1)
$$
其中$\pi'[i]=\begin{cases}\pi[i+1]-1,&\pi[i+1]>\pi[i]\\\pi[i+1],&\pi[i+1]<\pi[i]\end{cases}$

步骤二：由排列计算出下一个排列：

由一个字典序找到下一个字典序，比如序列 *26458173*，首先改变的数值一定是从个位开始。不改变个位以上的值能否将序列增大？不能；不改变十位以上的值只改变“73”能否将序列的值增大？不能；不改变百位以上的值只改变“173”能否将序列的值增大？可以，因为存在序列“317，371...” > "173"。观察可以得到以下规律，即找到下标为 $i$ 的数字满足 $a[i]<a[i+1]$，且对于 $i+1$ 之后的序列都有 $a[i+1]>a[i+2]>\cdots>a[n]$。找到下标 $i$ 之后如何从“317，371，713，731”中找到最适合的序列？显然这个序列是“317”。因此还应该找到下标 $j$ 满足 $a[j]$ 刚好大于 $a[i]$即 $a[j+1],a[j+2],...,a[n]<a[i],a[j]>a[i]$，然后 $\text{swap}(a[i],a[j])$，将 $a[i+1:n]$ 进行逆序处理即可得到下一个数列。

程序如下：

```c++
#include <bits/stdc++.h>
#define MAX 20+5
using namespace std;

int a[MAX],b[MAX],fac[MAX];

int dictIndex(int a[], int n){	//计算字典序
    int s = 0;
    for (int j = 0; j < n; ++j) {
        for(int i=j+1;i<n;i++)if(a[i]>a[j])a[i]--;	//对a[j+1:n]大于a[j]元素进行-1
        s+=(a[j]-1)*fac[n-j-1];		// 加每层的序号 (π[i]-1)*(n-i-1)!
    }
    return s;
}


int main(){
    int n;
    scanf("%d",&n);
    fac[0]=1;
    for(int i=0;i<n;i++){
        fac[i+1]=(i+1)*fac[i];
        scanf("%d",&b[i]);
        a[i]=b[i];
    }
    cout<<dictIndex(a,n)<<endl;	//得到字典序
    int i=n-2;
    while(b[i]>b[i+1])i--;	//找到可以增大的序号
    int j=i+1;
    while(j+1<n&&b[j+1]>b[i])j++;
    swap(b[i],b[j]);		//找到可以交换的序号
    i++,j=n-1;
    while(i<j)swap(b[i++],b[j--]);	//对a[i+1:n]进行逆序处理
    for (int k = 0; k < n; ++k) cout<<b[k]<<" ";//输出
    return 0;
}
```



## 六. 贪心

贪心算法出题形式不定，并且证明较难。

## 七. 动态规划

### 1. 背包问题

视频讲解：https://www.bilibili.com/video/BV1qt411Z7nE

🔵01背包问题

> 每个物品只能选或者不选两种情况

使用 $f[i][j]$ 来表示轮到选择第 $i$ 个物品的时候体积为 $j$ 的价值，则可以得到dp方程：
$$
f(i,j)=\begin{cases}f(i-1,j),&\text{discard}\\f(i-1,j-v[i])+w[i],&\text{selected}\end{cases}
$$
初次得到：

```c++
#include<iostream>
using namespace std;

const int N = 1010;
int w[N],v[n],dp[N][N];	//w价值数组，v体积数组，dp数组

int main(){
    int n,m;	//物品数量，最大容积
    cin>>n>>m;
    for(int i=1;i<=n;i++)cin>>v[i]>>w[i];
    for(int i=1;i<n;i++){
        for(int j=0;j<=m;j++){
            dp[i][j]=dp[i-1][j];
            if(j>=v[i])
                dp[i][j]=max(dp[i][j],dp[i-1][j-v[i]]+w[i]);
        }
    }
    int res=0;
    for(int i=0;i<=m;i++)res = max(res,dp[n][m]);
    cout<<res<<endl;
    return 0;
}
```

优化空间：

```c++
#include<iostream>
using namespace std;

const int N = 1010;
int w[N],v[N],dp[N];	//w价值数组，v体积数组，dp数组

int main(){
    int n,m;	//物品数量，最大容积
    cin>>n>>m;
    for(int i=1;i<=n;i++)cin>>v[i]>>w[i];
    for(int i=1;i<=n;i++)
        for(int j=m;j>=v[i];j--){
            dp[j]=max(dp[j],dp[j-v[i]]+w[i]);
    		//采用倒序就不会导致dp[i-1][j-v[i]]的值改变
    		//如果这里的倒序改成正序，循环体不变，那就导致二维时候dp[i-1][j-v[i]]发生改变
             //那就变成完全背包问题了
        }
    cout<<dp[m]<<endl;
    return 0;
}
```

结果的值为01背包最后的最优结果为背包体积小于等于m的情况，如果想要找体积恰好为m的情况，需要将$dp[0]=0$之外，其他$dp[i]=-\infin$即可。

🔵完全背包问题

>每件物品可以选无限次

思路：由于每个物品都可以选无数次，那就将在遍历每个物品的时候一直选，直到选满背包的体积为止。设$dp[i],(i\le V)$ 为体积，每次遍历一个物品，依次更新 $dp[i+k*v[i]]=dp[i]+k*w[i]$，其中 $k$ 值满足 $0\le k\le M,\ i+M*v[i]\le V\le i+(M+1)*v[i]$

```c++
for(int i = 0; i < n; i++){	//依次选取物品
    for(int j = m; j >= v[i]; j--){	//依次从最大值开始减
        for(int k = 1; k * v[i] <= j; k++){	//依次选取k个物品i
            f[j] = max(f[j],f[j - k * v[i]] + k * w[i]);
        }
    }
}
```

优化时间复杂度：

```c++
#include<iostream>
using namespace std;
const int N = 1010;
int dp[N];

int main(){
    int n,m;
    cin>>n>>m;
    for(int i=0;i<n;i++){
        int v,w;
        cin>>v>>w;
        for(int j=v;j<=m;j++) //从低开始计算
            dp[j] = max(dp[j],dp[j-v]+w);	
        	//此时就包含了取(k-1)个物品i的情况，数学归纳证明
    }
    cout<<dp[m]<<endl;
    return 0;
}
```

🔵多重背包问题

> 每个物品选择的上限次数不同

有了前面两道的基础，这道题就简单了

未优化：O(n^3^)https://www.acwing.com/problem/content/4/

```c++
#include<iostream>
using namespace std;
const int N = 1010;
int dp[N];

int main(){
    int n,m;
    cin>>n>>m;
    for(int i=0;i<n;i++){
        int v,w,cnt;
        cin>>v>>w>>cnt;
        for(int j=m;j>=v;j--){
            for(int k=1;k<=cnt&&k*v<=j;k++)		//就是完全背包的O(n^3)样例，加个cnt限制即可
                dp[j] = max(dp[j],dp[j-k*v]+k*w);
        }
    }
    cout<<dp[m]<<endl;
    return 0;
}
```

**二进制优化：**https://www.acwing.com/problem/content/5/

> 思考如何将混合背包问题转化成01背包问题

由于多重背包问题限制了每个物品的最多拿取的次数，因此不如使用拆分的思想将m个相同的物品 $i$，套用01背包O(n^2^)的解法实现时间复杂度的减少。

假如一个物品 $i$ 价值为 $w$ 有 $10$ 个，那么根据二进制来讲10个用4个二进制数来进行表示，最高为1010。每次进行分割的时候可以分为1，2，4，8个。由于1+2+4+8=15超过了10，因此最后一个8可以用3来替换。那么10以内的数字就可以用1，2，4，3表示为：

1 = 1

2 = 2	3 = 1 +2

4 = 4	5 = 1 + 4	6 = 2 + 4

7 = 1 + 2 + 4	8 = 1 + 4 + 3	9 = 2 + 4 + 3	10 = 1 + 2 + 4 + 3

这样每个数字只出现了一遍，但是经过组合之后仍可以凑满从 $0\sim10$所有的数字，因此在内层循环中的复杂度就减为了 $O(\log_2 n)$ 数量级，对于$dp[i]$ 来说，如果 $dp[i]$ 值更新，那么就选取某个基数，如果未更新就不选取即可，总之最大值为10。

```c++
#include <bits/stdc++.h>

using namespace std;
const int N = 2020;

int dp[N];

struct Good{
    int v,w;
};

int main(){
    int n,m;
    cin>>n>>m;
    vector<Good> goods;
    for(int i=0;i<n;i++){
        int v,w,s;
        cin>>v>>w>>s;
        for(int k=1;k<=s;k*=2){
            s-=k;
            goods.push_back({k*v,k*w});
        }
        if(s>0)goods.push_back({s*v,s*w});
    }
    for(auto good:goods)
        for(int i=m;i>=good.v;i--)
            dp[i] = max(dp[i],dp[i-good.v] + good.w);
    cout<<dp[m]<<endl;
}
```

## 八. 排序

### 1. 快速排序

```c
void quicksort(int *a, int low, int high){
    if(low >= high)return;
    int x = a[(low + high) / 2], i = low - 1,j = high + 1;
    while(i<j){
        do i++; while(a[i]<x);	//与x相同的情况会直接略过
        do j--; while(a[j]>x);
        if(i<j)swap(a[i],a[j]);
    }
    quicksort(low, j);	//最终a[j]<x,a[i]>x,因此分界点为j
    quicksort(j+1, high);
}
```

### 2. 桶排序

> 使用前提：数据均匀分布。桶的数量=$\sqrt n$

```c++
void bucketSort(int *a, int n){
    int bucketCounts = sqrt(n) + 1;
    vector<node*> buckets(bucketCounts,new node(0));
    for(int i=0;i<n;i++){
        node* head = buckets[a[i]/bucketCounts];
        head = insert(head,a[i]); //这里是有序插入
    }
    node* h;
    for(int i=0;i<n;i++)h=merge(buckets[i]);//有序合并各个桶的链表
    while(h!=NULL){//输出
        cout<<h->data<<" ";
        h = h->next;
    }
}
```

## 九. 数论

### 1. 大数取余

题目：[JJoffer-14](https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/)

🔵前置知识（余数的性质）：

* 恒等性：$(a\mod n) \mod n = a\mod n$
* 逆运算：$[(-a\mod n)+(a\mod n)]\mod n=0$
* 分配律：
  * $(a+b)\mod n=[(a\mod n)+(b\mod n)]\mod n$
  * $ab\mod n=[(a\mod n)(b\mod n)]\mod n$

🔵循环取余法
$$
x^a \mod  p = [(x ^{a-1} \mod  p)(x \mod  p)] \mod  p=[(x ^{a-1} \mod  p)x] \mod  p
$$
🔵快速幂求余
$$
{x^a \mod  p = }
\begin{cases}
(x^2 \mod  p)^{a // 2} \mod  p &  \text{, $a$ 为偶数} \\
{[(x \mod  p)(x ^{a-1} \mod  p)] \mod  p = [x(x^2 \mod  p)^{a//2}] \mod  p} & \text{, $a$ 为奇数} \\
\end{cases}
$$

### 2. 最大公约数和最小公倍数

最大公约数(greatest common division)和最小公倍数(Least common multiple)的关系：
$$
\text{lcm}(a,b)=\dfrac{a\cdot b}{\gcd(a,b)}
$$


最大公约数：

```c++
int gcd(int a,int b){
    if(b)while((a%=b)&&(b%=a));
    return a+b;
}

int gcd(int a, int b){
    return b ? gcd(b, a % b) : a;
}
```

最小公倍数：

```c++
int lcm(int a,int b){
    return a*b/gcd(a,b);
}
```

### 3. 因式分解定理

对于任意数$N$都有：
$$
N = P_1^{\alpha_1}\times P_2^{\alpha_2}\times ...\times P_k^{\alpha_k}
$$
其中 $P$ 为质数，$\alpha$ 为正整数

### 4. 线性筛法求素数

可以在 $O(n)$ 的时间复杂度内求得 $1\sim n$ 中所有的质数以及每个数的最小质因子。

```c
#include "bits/stdc++.h"

using namespace std;

const int N = 1000010;
vector<int> primes;
bool st[N]; // true - 合数; false - 质数
int min_factor[N];


void getPrimes(int n) {
    // get all the primes which lower equal than n.
    for (int i = 2; i <= n; ++i) {  // 虽然由两层循环但是其时间复杂度确实为O(n)
        if (!st[i]) min_factor[i] = i, primes.push_back(i);
        for (int j = 0; i * primes[j] <= n; ++j) {
            st[i * primes[j]] = true;
            min_factor[i * primes[j]] = primes[j];  // 记录最小质因子
            // 之后两个数字不互质就表示所得乘积不是由最小质因子乘法得到
            // 因此需要break
            if (i % primes[j] == 0) break;
        }
    }
}

int main() {
    getPrimes(20000);
    for (int i = 2; i < 100; ++i) {
        if(!st[i])cout<<i<< endl;
    }
}
```

性质：

1. 被筛选掉的一定是质数，并且是由其最小质因子筛选掉的。（可以根据这个性质得到其最小质因子）
2. 所有的合数一定会被筛掉！因为只有在碰到其最小质因子就会筛掉，因此不会遗漏。

### 5. 约数

由于对于任意数$N$都有：
$$
N = P_1^{\alpha_1}\times P_2^{\alpha_2}\times ...\times P_k^{\alpha_k}
$$
其中 $P$ 为质数，$\alpha$ 为正整数。

数字 $N$ 约数性质有：

* 约数个数就是 $(\alpha_1+1)(\alpha_2+1)\cdots (\alpha_k+1)$ 
* 所有约数之和是 $\displaystyle \sum_{i=0}^{\alpha_1}P_1^i\cdot\sum_{i=0}^{\alpha_2}P_2^i\cdots\sum_{i=0}^{\alpha_k}P_k^i$



## 十. 枚举与哈希

### 1. 原地哈希

参考：[原地哈希](https://blog.css8.cn/post/4942471.html)

题目：

* [41. 缺失的第一个正数](https://leetcode.cn/problems/first-missing-positive/)

对于一个长度为 n 的数组，所有数的范围都在 $[0,n-1]$ 并且都不相同，使用 $O(n)$ 的时间复杂度进行排序。

原地哈希的思想：

* 如果 $a[i] \neq i$，那么将数字a[i]放置到索引为a[i]的位置上，即 $\text{swap}(a[i], a[a[i]])$。

![image-20220516200831557](算法心法.assets/image-20220516200831557.png)

代码：

```java
private void inplaceHash(int[] arr) {
    for (int i = 0; i < arr.length; i++) {
        while (arr[i] != i)
            swap(arr[i], arr[arr[i]]);
    }
}
```



## 十一. 字符串

### 1. manacher 算法

参考：https://www.bilibili.com/video/BV1L54y1D7pa

例题：[5. 最长回文子串 - 力扣](https://leetcode-cn.com/problems/longest-palindromic-substring/)

寻找字符串中的最长回文子串(非子序列)的线性算法。

首先是对字符串的预处理，由于回文串的长度可能是基数或者偶数，因此由中心展开的时候会不方便，因此需要进行填充，比如 "aa" 需要填充为 "#a#a#"。

manacher算法中有几个重要的概念定义：

1. maxRight，即基于中心点所能延申最长回文串的右边界下标。
2. mirror，即当循环遍历 i < maxRight 的时候在这个回文串中的对称下标。

使用 p[] 数组来记录当前中心点向右所能延申的最大长度，其数值也是以当前为中心点回文串的长度。

当 i ≥ maxRight 的时候，老老实实进行中心扩散；

当 i < maxRight 的时候，可以根据对称的思想来进行简化计算。

![image-20220420154311747](算法心法.assets/image-20220420154311747.png)

因此当 i < maxRight 的时候，可以分为以下三种清空：

1. 当 p[mirror] < maxRight - i 时，以两者为中心的回文串都被主回文串包裹，p[i] = p[mirror]
2. 当 p[mirror] = maxRight - i 时，p[i] 的长度至少是 p[mirror] 然后进行中心扩散，扩散完之后更新maxRight 和 center
3. 当 p[mirror] > maxRight - i 时，p[i] = maxRight - i

### 2. KMP 算法

建议使用Sunday算法。

```c++
void get_next(string T,int next[]){
    int i = 0, j = -1;
    next[0] = -1;
    while (i<T.length()){
        if(j==-1||T[i]==T[j])next[++i]=++j;//根据前后缀更新next数组
        else j=next[j];
    }
}

int kmp(string s,string t){
    int i=0,j=0;
    int *next=new int[t.length()];
    memset(next,0,4*t.length());
    get_next(t,next);
    while(i<s.length()&&j<int(t.length())){
        if(j==-1||s[i]==t[j]){
            i++,j++;
        }else j=next[j];	//找到上一个前缀
    }
    if(j>=t.length())return i-t.length();
    return -1;
}
```

### 3. Sunday 算法

参考：[字符串匹配算法原理讲解(Hash、KMP、BM、Sunday) ](https://juejin.cn/post/6844904176036610062#heading-10)

Sunday 算法理解起来要比 KMP 和 BM 算法要更容易。Sunday 匹配算法是从左往右匹配，在匹配失败的时候关注主串中参与匹配的最末位的下一位字符，规则为：

* 如果该字符未在子串中出现，则子串右移的长度为子串长度+1
* 如果字符在子串中出现，则将主串中该字符与子串中最后一次出现该字符的位置进行对齐

Sunday 算法需要构建一个偏移表，存储每个字符的偏移量。

设文本串S为"ATTAAGGCACATAC"，模式串P为"ACAT"，模式串中字符的偏移量为:

```
shift[A] = 4 - max(A的位置) = 4 - 2 = 2

shift[C] = 4 - max(C的位置) = 4 - 1 = 3

shift[T] = 4 - max(t的位置) = 4 - 3 = 1

shift[其他] = 4 + 1 = 5
```

![img](算法心法.assets/1726a31f4e5f3307tplv-t2oaga2asx-zoom-in-crop-mark1304000.awebp)

![img](算法心法.assets/1726a35225a930cbtplv-t2oaga2asx-zoom-in-crop-mark1304000.awebp)

![img](算法心法.assets/1726a372e25b40f0tplv-t2oaga2asx-zoom-in-crop-mark1304000.awebp)

![img](算法心法.assets/1726a3ac01b0afb6tplv-t2oaga2asx-zoom-in-crop-mark1304000.awebp)

算法实现：

```java
private int[] shift = new int[512];
public int strStr(String a, String b) {
    int alen = a.length(), blen = b.length();
    Arrays.fill(shift, blen + 1);
    for (int i = 0; i < b.length(); i++) {
        shift[b.charAt(i)] = blen - i;
    }

    int m = 0, n;
    while (m <= alen - blen) {
        n = 0;
        while (a.charAt(m + n) == b.charAt(n)) {
            n++;
            if (n >= blen) return m;
        }
        if (m + blen >= alen) return -1;
        m += shift[a.charAt(m + blen)];
    }
    return -1;
}
```

## 番外：语言技巧

### Java 输入输出

参考：[Java中System.out.println效率较低](https://www.acwing.com/problem/content/discussion/content/7/)

对于需要Java中频繁进行输入输出，println效率较低，需要使用`BufferedWriter`以及`BufferedReader`

> 记得关闭流`close`和刷新`flush()`。

数据输入：

```java
public class P1227 {
    private static BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
    private static int N, K;
    private static int s[][];

    public static void main(String[] args) throws IOException {
        String[] strs = reader.readLine().split(" ");
        N = Integer.parseInt(strs[0]);
        K = Integer.parseInt(strs[1]);
        s = new int[N][2];
        for (int i = 0; i < N; i++) {
            String[] strs2 = reader.readLine().split(" ");
            s[i][0] = Integer.parseInt(strs2[0]);
            s[i][1] = Integer.parseInt(strs2[1]);
        }
        reader.close();
    }
}
```

数据输出：

```java
public static void main(String[] args) throws IOException {
    BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

    bw.write(min_cnt + "\n");
    
    // ,,,,

    bw.flush();
    bw.close();
}
```

