# Algorithm

## 前言

### 刷题网站：

* Leetcode：[Leetcode](https://leetcode-cn.com/problemset/algorithms/)
* acwing：[acwing](https://www.acwing.com/)
* 剑指Offer：[剑指Offer link](https://leetcode-cn.com/problem-list/xb9nqhhg/)
* 牛客网：[牛客网](https://www.nowcoder.com/exam/oj)

## 一. 数组与链表

### 1. 有环链表

🔵如何判断链表有环：

<img src="E:\Notes\algorithm\算法心法.assets\168178e06e2b0f1729f77522d3440c4.jpg" alt="168178e06e2b0f1729f77522d3440c4" style="zoom: 40%;" />

龟兔赛跑算法（快慢指针）：

刚开始指针A和指针B指向链表头，A每向前走一步，B就向前走两步。

如果无环，B会首先变成null空指针，B指针不可能追上A。

当B距离A有1个距离时，下一次迭代两者一定会相遇。

当B距离A有2个距离的时候，经过一次迭代就会变成第一种情况，因此一定会相遇。

**结论**：只要两者在环中，最后都一定会相遇。

🔵如何确定有环链表的起点：

由上面结论可推，当将环中的起点断开为链表的时候，在链表前半段的时候A不可能追上B，在后半段的时候根据初中数学之后可得两者最终在终点才能相遇，因此可得A与B每次相遇的地点都相同。

当第一次相遇的时候开始记录，第二次相遇的时候记录A走过的距离为 $K$ ，即得环的长度 $K$。

<img src="E:\Notes\algorithm\算法心法.assets\d5366ab77a944e857bcf091dca4685c.jpg" alt="d5366ab77a944e857bcf091dca4685c" style="zoom:50%;" />

由于环的长度为 $K$，设链表的长度为 $m$，因此让A和B同时回到链表起点，先让B走K步；然后A和B同时出发，当B指针与A指针相遇时，即可得到环头。

### 2. 双指针

题目：

* [三数之和](https://leetcode-cn.com/problems/3sum/)
* [最接近的三数之和](https://leetcode-cn.com/problems/3sum-closest/)
* [日志统计](https://www.acwing.com/problem/content/1240/)

### 3. 前缀和与差分数组

题目：

* [前缀和 (模板)](https://www.acwing.com/problem/content/797/)
* [子矩阵的和 (模板)](https://www.acwing.com/problem/content/798/)
* [差分 (模板)](https://www.acwing.com/problem/content/799/)
* [差分矩阵 (模板)](https://www.acwing.com/problem/content/800/)

🔵前缀和：

查询一个数组中间某段序列的和。

欲求$\displaystyle\sum_{i=l}^ra[i]$，设$S[j]=\displaystyle\sum_{i=0}^ja[i]$，则$\displaystyle\sum_{i=l}^ra[i]=S[r]-S[l-1]$。

扩展二维矩阵和。

<img src="E:\Notes\algorithm\算法心法.assets\c0fb61ece5e6adddf0932f33f547b22.jpg" alt="c0fb61ece5e6adddf0932f33f547b22" style="zoom:50%;" />

A区域之和=$S[i][j]-s[a][j]-s[i][b]+s[a][b]$

🔵差分矩阵

对于一个数组，要对中间 $[l,r]$ 都加上某个常数$c$，然后求最终的序列。

思想：利用前缀和的逆思想。对于原数组$a[i]$中加某个常数$c$，其对应的前缀和数组$s[i:n]$都需要加上C。因此可以利用这种逆思想将对应的数组看成前缀和数组，前缀和中的原数组即为差分数组。

构造差分数组的公式：$c[i]=a[i]-a[i-1]$，若要对区间 $[l,r]$ 都要加上某个常数C，则只需要 $c[l]+c$，$c[r+1]-c$即可，最终汇总数组 $c$ 的前缀和数组即可得到最终的序列。时间复杂度由原来的 $O(n^2)$ 将为了 $O(n)$。

### 4. 链表的数组表示法

题目：

* [单链表](https://www.acwing.com/problem/content/828/)

一般情况下对于链表的表示方法都是使用结构体的形式，创建的时候采用的是new的方法。然而这种方式对于数据量较大的情况就寄了，会导致TLE等情况，因此需要更加快速的方法来创建数组。

这里采用数组的方式来进行表示链表，用 $e[n]$ 存储链表中的信息，$en[n]$ 表示链表中对应下一个节点的索引。

## 二. 堆栈队列

### 1. hint

对于堆和队列两种数据结构，其操作只涉及到头和尾，因此对于已经有头和尾指针的情况下，就无需进行其他多余操作。

例题：[剑指 Offer 09. 用两个栈实现队列](https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/)



## 三. 树和森林

### 1. 树状数组和线段树

题目：

* [1264. 动态求连续区间和 (模板)](https://www.acwing.com/problem/content/1266/)

应用于单点修改和区间查询，时间复杂度为 $O(\log n)$

🔵树状数组

* $O(\log n)$快速求前缀和。
* 在某个位置的数，加上一个数

![image-20220223162823400](E:\Notes\algorithm\算法心法.assets\image-20220223162823400.png)

树状数组的层数是有对应位置数字二进制末尾几个零决定。

树状数组有三个必要操作：`lowbit(x), add(), query()`，分别表示特定计算，对某个元素添加一个值以及查询前缀和。其中$\text{lowbit(x)}=x\&-x$。其查询前缀和以及进去区间修改的时间复杂度为$O(\log n)$

求位置索引`x`之前序列前缀和：

```c
for(int i=x;i>0;i-=lowbit(i))res+=c[i];
```

在位置索引`x`添加数值`v`后需要进行的序列修改：

```c
for(int i = x; i <= n; i += lowbit(x))c[i]+=v;
```

模板：

```c++
#include "iostream"
#include "cstdio"
#include "algorithm"

using namespace std;

typedef long long ll;

const int N = 100010;
int n, m;
int tr[N];

int lowbit(int x) {
    return x & -x;
}

void add(int t, int x) {
    for (int i = t; i <= n; i += lowbit(i)) tr[i] += x;
}

ll query(int t) {
    ll ans = 0;
    for (int i = t; i > 0; i -= lowbit(i)) {
        ans += tr[i];
    }
    return ans;
}

int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; ++i) {
        int item;
        scanf("%d", &item);
        add(i, item);
    }
    int k, a, b;
    while (m--) {
        scanf("%d%d%d", &k, &a, &b);
        if (k) add(a, b);
        else cout << query(b) - query(a - 1) << endl;
    }
}
```

🔵线段树

![img](E:\Notes\algorithm\算法心法.assets\线段树表示.png)

其维持的就是结构体数组，结构体中记录数组的边界和所保存的值。

基础线段树有四个操作：`pushup()`根据子节点的信息来更新父节点，`build()`构造线段树，`modify()`单点修改，`query()`区间查询。

模板：

```c++
#include "cstdio"

const int N = 100010;
int arr[N];
struct Node {
    int l, r;
    int sum;
} tr[N * 4 + 1];
int n, m;

void pushup(int u) {
    tr[u].sum = tr[u << 1].sum + tr[u << 1 | 1].sum;
}

void build(int u, int l, int r) {
    if (l == r) tr[u] = {l, r, arr[l]};
    else {
        tr[u] = {l, r};
        int mid = l + r >> 1;
        build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
        pushup(u);
    }
}

void modify(int u, int t, int x) {
    if (tr[u].l == tr[u].r)tr[u].sum += x;
    else {
        int mid = tr[u].l + tr[u].r >> 1;
        if (t <= mid) modify(u << 1, t, x);
        else modify(u << 1 | 1, t, x);
        pushup(u);
    }
}

int query(int u, int l, int r) {
    if (tr[u].l >= l && tr[u].r <= r)return tr[u].sum;
    int mid = tr[u].l + tr[u].r >> 1;
    int sum = 0;
    if (l <= mid) sum = query(u << 1, l, r);
    if (r > mid) sum += query(u << 1 | 1, l, r);
    return sum;
}

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; ++i) scanf("%d", &arr[i]);
    build(1, 1, n);
    int k, a, b;
    for (int i = 0; i < m; ++i) {
        scanf("%d%d%d", &k, &a, &b);
        if (k) modify(1, a, b);
        else printf("%d\n", query(1, a, b));
    }
}
```



## 四. 图论



## 五. 递归分治

### 1. 二分思想

题目：

* [789. 数的范围 (模板题)](https://www.acwing.com/problem/content/791/)

思想：

1. 确定一个区间，使得答案一定在区间内。
2. 找一个性质满足两点：
   * 性质具有二段性，前段满足条件，后段不满足条件
   * 答案是具有分界点的

比如整数二分。

找区间左端点时：$\text{mid}=\dfrac{l+r}{2}$，找区间右端点的时候：$\text{mid}=\dfrac{l+r+1}{2}$

因为对于奇数除以2的时候默认向下取整。因此找左端点的时候默认端点靠左，找右端点的时候计算mid时候需要加一，让右端点的范围更加靠右。

```c
#include<cstdio>
#include<cstring>

int n, q;

int s[100010];

int main(){
	scanf("%d%d", &n, &q);
	for(int i=0;i<n;i++)scanf("%d", &s[i]);
	for(int i = 0; i < q; i ++){
		int t;
		scanf("%d", &t);
		
		int l = 0, r = n - 1;
		while(l < r){		// 找左端点
			int mid = l + r >> 1;
			if(s[mid] >= t) r = mid;
			else l = mid + 1;
		}
		
		if(s[r] == t){
			printf("%d ", r);
			r = n - 1;
			while(l < r){	// 找右端点
				int mid = l + r + 1 >> 1; // l = mid +1向上取整
				if(s[mid] <= t) l = mid;
				else r = mid - 1;
			}
			printf("%d\n", r);
		}else{
			printf("-1 -1\n");
		}
	} 
	return 0;
}
```

## 六. 贪心

贪心算法出题形式不定，并且证明较难。

## 七. 动态规划



## 八. 排序



## 九. 数论

### 1. 大数取余

题目：[JJoffer-14](https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/)

🔵前置知识（余数的性质）：

* 恒等性：$(a\mod n) \mod n = a\mod n$
* 逆运算：$[(-a\mod n)+(a\mod n)]\mod n=0$
* 分配律：
  * $(a+b)\mod n=[(a\mod n)+(b\mod n)]\mod n$
  * $ab\mod n=[(a\mod n)(b\mod n)]\mod n$

🔵循环取余法
$$
x^a \mod  p = [(x ^{a-1} \mod  p)(x \mod  p)] \mod  p=[(x ^{a-1} \mod  p)x] \mod  p
$$
🔵快速幂求余
$$
{x^a \mod  p = }
\begin{cases}
(x^2 \mod  p)^{a // 2} \mod  p &  \text{, $a$ 为偶数} \\
{[(x \mod  p)(x ^{a-1} \mod  p)] \mod  p = [x(x^2 \mod  p)^{a//2}] \mod  p} & \text{, $a$ 为奇数} \\
\end{cases}
$$

### 2. 最大公约数和最小公倍数

最大公约数(greatest common division)和最小公倍数(Least common multiple)的关系：
$$
\text{lcm}(a,b)=\dfrac{a\cdot b}{\gcd(a,b)}
$$


最大公约数：

```c++
int gcd(int a,int b){
    if(b)while((a%=b)&&(b%=a));
    return a+b;
}

int gcd(int a, int b){
    return b ? gcd(b, a % b) : a;
}
```

最小公倍数：

```c++
int lcm(int a,int b){
    return a*b/gcd(a,b);
}
```

### 3. 因式分解定理

对于任意数$N$都有：
$$
N = P_1^{\alpha_1}\times P_2^{\alpha_2}\times ...\times P_k^{\alpha_k}
$$
其中 $P$ 为质数，$\alpha$ 为正整数

### 4. 线性筛法求素数

可以在 $O(n)$ 的时间复杂度内求得 $1\sim n$ 中所有的质数以及每个数的最小质因子。

```c
#include "bits/stdc++.h"

using namespace std;

const int N = 1000010;
vector<int> primes;
bool st[N]; // true - 合数; false - 质数
int min_factor[N];


void getPrimes(int n) {
    // get all the primes which lower equal than n.
    for (int i = 2; i <= n; ++i) {  // 虽然由两层循环但是其时间复杂度确实为O(n)
        if (!st[i]) min_factor[i] = i, primes.push_back(i);
        for (int j = 0; i * primes[j] <= n; ++j) {
            st[i * primes[j]] = true;
            min_factor[i * primes[j]] = primes[j];  // 记录最小质因子
            // 之后两个数字不互质就表示所得乘积不是由最小质因子乘法得到
            // 因此需要break
            if (i % primes[j] == 0) break;
        }
    }
}

int main() {
    getPrimes(20000);
    for (int i = 2; i < 100; ++i) {
        if(!st[i])cout<<i<< endl;
    }
}
```

性质：

1. 被筛选掉的一定是质数，并且是由其最小质因子筛选掉的。（可以根据这个性质得到其最小质因子）
2. 所有的合数一定会被筛掉！因为只有在碰到其最小质因子就会筛掉，因此不会遗漏。

### 5. 约数

由于对于任意数$N$都有：
$$
N = P_1^{\alpha_1}\times P_2^{\alpha_2}\times ...\times P_k^{\alpha_k}
$$
其中 $P$ 为质数，$\alpha$ 为正整数。

数字 $N$ 约数性质有：

* 约数个数就是 $(\alpha_1+1)(\alpha_2+1)\cdots (\alpha_k+1)$ 
* 所有约数之和是 $\displaystyle \sum_{i=0}^{\alpha_1}P_1^i\cdot\sum_{i=0}^{\alpha_2}P_2^i\cdots\sum_{i=0}^{\alpha_k}P_k^i$



## 十. 枚举与哈希



## 番外：语言技巧

### Java 输入输出

参考：[Java中System.out.println效率较低](https://www.acwing.com/problem/content/discussion/content/7/)

对于需要Java中频繁进行输入输出，println效率较低，需要使用`BufferedWriter`以及`BufferedReader`

> 记得关闭流`close`和刷新`flush()`。

数据输入：

```java
public class P1227 {
    private static BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
    private static int N, K;
    private static int s[][];

    public static void main(String[] args) throws IOException {
        String[] strs = reader.readLine().split(" ");
        N = Integer.parseInt(strs[0]);
        K = Integer.parseInt(strs[1]);
        s = new int[N][2];
        for (int i = 0; i < N; i++) {
            String[] strs2 = reader.readLine().split(" ");
            s[i][0] = Integer.parseInt(strs2[0]);
            s[i][1] = Integer.parseInt(strs2[1]);
        }
        reader.close();
    }
}
```

数据输出：

```java
public static void main(String[] args) throws IOException {
    BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

    bw.write(min_cnt + "\n");
    
    // ,,,,

    bw.flush();
    bw.close();
}
```

